--- 
layout: post
title: "GraphML With JUNG: Saving Out"
categories: 
- Code
- Java
- JUNG
tags: 
- graphml
- java
- jung
- saving graphs to xml
status: publish
type: post
published: true
meta: 
  _wp_old_slug: ""
  _wpas_skip_twitter: "1"
  _wpas_skip_fb: "1"
---
This one of two posts I'm dedicating to saving out to and loading from GraphML using the JUNG library. These are two parts of a really good library that lack sufficient documentation.
[sourcecode lang="java"]GraphMLWriter&lt;MyVertex, MyEdge&gt; graphWriter =
                 new GraphMLWriter&lt;MyVertex, MyEdge&gt; ();

PrintWriter out = new PrintWriter(
                      new BufferedWriter(
                          new FileWriter(filename)));
[/sourcecode]
You first need to create your writers. The first line of code creates your <code>GraphMLWriter</code> with your custom Edge and Vertex classes specified.

<!--more-->The next line creates a standard Java <code>PrintWriter,</code> which takes in input from a <code>BufferedWriter</code>, which in turn is connected to a <code>FileWriter </code>that writes to the file specified by the <code>String filename</code>. (The BufferedWriter isn't necessary in all cases)
[sourcecode lang="java"]graphWriter.addVertexData(&quot;x&quot;, null, &quot;0&quot;,
    new Transformer&lt;MyVertex, String&gt;() {
        public String transform(MyVertex v) {
            return Double.toString(graphy.layout.getX(v));
        }
    }
);

graphWriter.addVertexData(&quot;y&quot;, null, &quot;0&quot;,
    new Transformer&lt;MyVertex, String&gt;() {
        public String transform(MyVertex v) {
            return Double.toString(graphy.layout.getY(v));
       }
    }
);[/sourcecode]
By default, the XML file generated by the does not store the X and Y coordinates of the vertices, so when you load a graph from a file, all the vertices are placed on top of each other at one point on the canvas.

These are two bits of code that tell my GraphMLWriter to add this information in to the file it creates. The <code>addVertexData</code> library function looks like this:
[sourcecode lang="java"]public void addVertexData (
    String id, String description,
        String default_value,
            Transformer&lt;V, String&gt; vertex_transformer)[/sourcecode]
The <code>id</code> is the string that I want added into my XML file, and will be what I will be using to extract the value while loading my graph from the file. The <code>description</code> would describe the new data field you're adding, I've omitted that here. The <code>default_value</code> is again a string, and the last argument is what makes it all work.

A <code>Transformer</code> can be looked as just something that transforms one object into another. It has an abstract function <code>transform </code>that every transformer is required to implement. In this case, the transformer is required to return a <code>String</code> that is needed by the GraphMLWriter, and I've used my <code>AbstractLayout graphy.layout </code>to extract the X and Y coordinates of the vertex and return them as strings to my GraphMLWriter.
[sourcecode lang="java"]graphWriter.save(g, out);[/sourcecode]
This final bit of code saves out the <code>Graph g</code> using the <code>PrintWriter out</code>.

Note: You'll either need to enclose the entire block of code to save your graph in a try-catch block that catches an <code>IOException</code>, or declare the calling function with <code>throws IOException</code>.
