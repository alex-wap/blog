<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <meta name=viewport content="width=device-width, initial-scale=1.0">
        <meta name=description content="Blog of Emaad Ahmed Manzoor">
        
        <title>
          
            Infinite Loops | 
          
          Emaad Ahmed Manzoor
        </title>

        <script src=http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML.js type=text/javascript></script>
        <script>
            MathJax.Hub.Config({
              "HTML-CSS": {
                linebreaks: {
                    automatic: true,
                    width: "70% container"
                },
                styles: {
                    ".MathJax .math": {
                        //"border": "1px solid #ccc",
                        //"margin": "0.1em 0",
                        //"padding": "0.3em",
                        //"vertical-align": "middle"
                    },
                    ".MathJax_Display .math": {
                        "border": "none",
                        "padding": "0",
                    }
                },
                scale: 100
              }
            });
        </script>
                
        <link rel=stylesheet type=text/css href=/css/pure-min.css>
        <link rel=stylesheet type=text/css href=/css/github.css>
        <link rel=stylesheet type=text/css href=/css/styles.css>
        <link rel=stylesheet type=text/css href=/css/font-awesome/css/font-awesome.min.css>
        
        <link rel=alternate type=application/rss+xml title="RSS feed for eyeshalfclosed.com" href="/feed.xml">
    </head>
    <body>
        <div class="container pure-g-r">
            <div class=pure-u-1-4>
                <div class=author-info>
    <img src="/images/author-image.jpeg" class=author-image />
    <h1 class=author-name><a href=/>Emaad Ahmed Manzoor</a></h1>
    <div class=nav>
        <a href="https://github.com/emaadmanzoor"><i class=icon-github-alt></i></a>
        <a href="https://twitter.com/emaadmanzoor"><i class=icon-twitter></i></a>
        <a href="https://linkedin.com/in/emaadmanzoor"><i class=icon-linkedin></a></i>
        <a href="http://feeds.feedburner.com/eyeshalfclosed"><i class=icon-rss></i></a>
    </div>
    <div class=home-nav>
        <ul>
            <li><a href="https://scholar.google.com/citations?user=TcMyxM0AAAAJ">Scholar</a></li>
            <li><a href="/blog/">Blog</a>
                &nbsp;|&nbsp;
                <a href="/jrnl/">jrnl</a></li>
            <li><a href="/projects/">Projects</a>
                &nbsp;|&nbsp;
                <a href="https://github.com/emaadmanzoor">Code</a>
            </li>
            <li><a href="/talks/">Talks</a></li>
            <li><a href="/service/">Service</a></li>
            <li><a href="/teaching/">Teaching</a></li>
            <li>
                <a class=resume-link href="/cv.pdf">CV</a><br/>
                <span class=resume-update>(Updated Mar. '19)</span>
            </li>
        </ul>
    </div>
</div>

            </div>
            <div class=pure-u-3-4>
                <div class=right-column>
                    <div class=post>
    
    <ul class=post-meta>
    
    <li class=publish-time><i class=icon-calendar></i>March 27, 2013</li>
    
        <li>&middot;</li>
        <li><a href="/tags/#scala-ref">#scala</a></li>
    
        <li>&middot;</li>
        <li><a href="/tags/#clojure-ref">#clojure</a></li>
    
        <li>&middot;</li>
        <li><a href="/tags/#functional-programming-ref">#functional-programming</a></li>
    
</ul>

    <h1 class=title-large>Infinite Loops</h1>
    <div class=content>
        <p>My second attempt at Coursera’s <a href="https://class.coursera.org/progfun-2012-001/">Scala course</a> turned out to have a
refreshingly twisty plot. The grand plan this time is to blaze through the
course using both Scala and Clojure, and then top it off by dishing out
code reviews of <a href="https://github.com/nathanmarz/storm/">Storm</a> (Clojure) and <a href="http://kafka.apache.org/">Kafka</a> (Scala).</p>

<p>I didn’t expect the first week to hit me with a bunch of creepy differences
in details that aren’t skin-deep. How hard could it be to write an infinite
loop, right?</p>

<h2 class="no_toc" id="contents">Contents</h2>

<ul id="markdown-toc">
  <li><a href="#the-background-function-evaluation" id="markdown-toc-the-background-function-evaluation">The Background: Function Evaluation</a></li>
  <li><a href="#the-plan-infinite-recursion" id="markdown-toc-the-plan-infinite-recursion">The Plan: Infinite Recursion</a></li>
  <li><a href="#the-twist-i-tco" id="markdown-toc-the-twist-i-tco">The Twist I: TCO</a></li>
  <li><a href="#the-twist-ii-lazy-evaluation" id="markdown-toc-the-twist-ii-lazy-evaluation">The Twist II: Lazy Evaluation</a></li>
  <li><a href="#bonus-twist-really-lazy-evaluation" id="markdown-toc-bonus-twist-really-lazy-evaluation">Bonus Twist: Really Lazy Evaluation</a></li>
</ul>

<h2 id="the-background-function-evaluation">The Background: Function Evaluation</h2>

<p>The week started with some basic concepts on the substitution model of
function execution. In a nutshell, there are two ways a called function can
be reduced to a value in the substitution model:</p>

<ul>
  <li><strong>Call-by-value:</strong> The function’s arguments are fully reduced before the
 function is applied to them. This is the <em>default</em> method of substitution
 in both Clojure and Scala. An example series of reductions could be:</li>
</ul>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">sumOfSquares</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">sumOfSquares</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c"># Argument reduced to a value</span>
      <span class="o">=&gt;</span> <span class="n">square</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c"># Function applied</span>
        <span class="o">=&gt;</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">25</span>
          <span class="o">=&gt;</span> <span class="mi">41</span></code></pre>
</figure>

<ul>
  <li><strong>Call-by-name:</strong> Applies the function to unreduced arguments. The arguments
 are evaluated in the body of the function <em>if needed</em>. This gives us a
 convenient way to short-circuit evaluation of a parameter if it is unused in
 the function body. An example series of reductions for this would be:</li>
</ul>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">sumOfSquares</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">square</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="c"># Function applied</span>
      <span class="o">=&gt;</span> <span class="n">square</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c"># Argument reduced</span>
        <span class="o">=&gt;</span> <span class="mi">16</span> <span class="o">+</span> <span class="mi">25</span>
          <span class="o">=&gt;</span> <span class="mi">41</span></code></pre>
</figure>

<p>Note that I have omitted some of the reduction steps for brevity.</p>

<h2 id="the-plan-infinite-recursion">The Plan: Infinite Recursion</h2>

<p>An in-class exercise was to write a function performing the boolean-and of two variables
without using the built-in primitives. The crux was about remembering the short-circuits:</p>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">true</span> <span class="o">&amp;&amp;</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">Y</span>
  <span class="n">false</span> <span class="o">&amp;&amp;</span> <span class="n">Y</span> <span class="o">==</span> <span class="n">false</span></code></pre>
</figure>

<p>In Scala, this can be quickly accomplished by:</p>

<figure class="highlight">
  <pre><code class="language-scala" data-lang="scala">  <span class="k">def</span> <span class="n">and2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span> </code></pre>
</figure>

<p>But the method above can be broken, and our weapon of choice is the infinite recursion loop:</p>

<figure class="highlight">
  <pre><code class="language-scala" data-lang="scala">  <span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">loop</span></code></pre>
</figure>

<p>This defines a function that calls itself. Note that because this is a <em>def</em> and not
a <em>val</em>, the right-hand-side of the assignment is evaluated only when the function is
called. <em>val</em>, in contrast, evaluates the right-hand-side at definition time.</p>

<p>Now if we provide this function as an argument to our boolean-and’er, we see the following
reduction happening (remember that Scala reduces by-value):</p>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">and2</span><span class="p">(</span><span class="n">false</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="c"># Hangs when trying to evaluate the "loop" method</span></code></pre>
</figure>

<p>What we’d like is to not evaluate the second parameter at all if the first is false.
To achieve this, we can coax Scala into reducing a particular argument by-name instead:</p>

<figure class="highlight">
  <pre><code class="language-scala" data-lang="scala">  <span class="k">def</span> <span class="n">and2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="o">:=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span></code></pre>
</figure>

<p>The reduction for this would then be:</p>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">and2</span><span class="p">(</span><span class="n">false</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="k">if</span> <span class="p">(</span><span class="n">false</span><span class="p">)</span> <span class="n">loop</span> <span class="k">else</span> <span class="n">false</span>
       <span class="o">=&gt;</span> <span class="n">false</span></code></pre>
</figure>

<p>The infinite <em>loop</em> is never evaluated, since we have forced Scala to evaluate the
second parameter by-name instead of by-value. Hence, we achieve our desired behaviour.</p>

<h2 id="the-twist-i-tco">The Twist I: TCO</h2>

<p>Translating this functionality to Clojure seemed trivial until I slammed into some
odd behaviour. To start with, let’s write an innocent infinite loop function:</p>

<figure class="highlight">
  <pre><code class="language-clojure" data-lang="clojure"><span class="w">  </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">myLoop</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nf">myLoop</span><span class="p">))</span></code></pre>
</figure>

<p>And let’s run this method and watch it eat up our CPU:</p>

<figure class="highlight">
  <pre><code class="language-clojure" data-lang="clojure"><span class="w">  </span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">myLoop</span><span class="p">)</span><span class="w">
  </span><span class="n">StackOverflowError</span><span class="w">  </span><span class="n">user/myLoop</span><span class="w"> </span><span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="no">:1</span><span class="p">)</span></code></pre>
</figure>

<p>Unexpected, right? I was stumped! After some headless-chicken-scrambling
into the details of function argument reduction in Clojure, I
stumbled onto <a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion">this illuminating blog post</a>, comparing infinite loops
in a number of languages. The sneaky culprit turned out to be
TCO, or <em>tail-call optimization</em>.</p>

<p>Let’s look at what this means by a simple reduction example, applied to calculating
the sum of ones upto <em>N</em>. Here is the non-tail-call-optimized reduction:</p>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">sumToN</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># sumToN(1) returns</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>     <span class="c"># sumToN(2) returns</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span>         <span class="c"># sumToN(3) returns</span>
    <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span>             <span class="c"># sumToN(4) returns</span>
    <span class="o">=&gt;</span> <span class="mi">5</span>                 <span class="c"># sumToN(5) returns </span></code></pre>
</figure>

<p>Observe how the chain of execution gets wider with increasing <em>N</em>. Each function call
is appended to the call stack. Only when the last function is reduced does
the stack get collapsed by subsequently reducing each function.</p>

<p>Our <em>sumToN</em> function can be tail-call-optimized by simply adding an additional
laccumulator parameter. This parameter, along with the current <em>N</em> value, maintains
the <em>state</em> of the function evaluation at that instant.</p>

<figure class="highlight">
  <pre><code class="language-python" data-lang="python">  <span class="n">sumToN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="n">sumToN</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">=&gt;</span> <span class="mi">5</span></code></pre>
</figure>

<p>Notice how the evaluation of this function always has a constant tail length, and hence
accumulates a constant amount of space on the call stack for any <em>N</em> value.</p>

<p><strong>Scala Does Tail-Call Optimization By Default</strong></p>

<p>And this happens really quietly. This is why the Scala infinite loop function we wrote
earlier actually executed infinitely. In contrast, the Clojure one never runs, and the
infinite function additions to the call stack eventually trigger a stack overflow.</p>

<h2 id="the-twist-ii-lazy-evaluation">The Twist II: Lazy Evaluation</h2>

<p>To mimic Scala’s behaviour, let’s enforce tail-call optimization in Clojure:</p>

<figure class="highlight">
  <pre><code class="language-clojure" data-lang="clojure"><span class="w">  </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">myLoop</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">((</span><span class="nb">loop</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nf">recur</span><span class="p">))))</span></code></pre>
</figure>

<p>Now let’s try the same boolean-and’ing exercise we did in Scala:</p>

<figure class="highlight">
  <pre><code class="language-clojure" data-lang="clojure"><span class="w">  </span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">and2</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">false</span><span class="p">))</span><span class="w">
  </span><span class="o">#</span><span class="ss">'user/and2</span><span class="w">
  </span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">and2</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="n">myLoop</span><span class="p">)</span><span class="w"> </span><span class="c1">; Should short-circuit</span><span class="w">
  </span><span class="n">false</span><span class="w">
  </span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">and2</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="n">myLoop</span><span class="p">)</span><span class="w">  </span><span class="c1">; Should hang</span><span class="w">
  </span><span class="o">#</span><span class="n">&lt;user$myLoop</span><span class="w"> </span><span class="n">user$myLoop</span><span class="o">@</span><span class="mi">4</span><span class="n">d91f801&gt;</span></code></pre>
</figure>

<p>What did it just dump out on our feet? Where is our infinite loop?</p>

<p>The culprit this time turns out to be <em>lazy evaluation</em>; a function is not
evaluated to its return value unless explicitly asked to. Clojure uses lazy evaluation
by default, so instead of evaluating the function, it simply returns it to
us, should we choose to explicitly evaluate it later. In contrast, Scala
begins evaluating the <em>loop</em> function within the if-condition and hence
runs into an infinite loop. That weird dump is a representation of our Clojure function.</p>

<h2 id="bonus-twist-really-lazy-evaluation">Bonus Twist: Really Lazy Evaluation</h2>

<p>Another interesting fact a comment in <a href="http://paulbarry.com/articles/2009/09/02/infinite-recursion">this blog post</a> pointed out was an important
difference between lazy evaluation in Haskell and Clojure. Consider this
Haskell infinitely-recursive function:</p>

<figure class="highlight">
  <pre><code class="language-haskell" data-lang="haskell">  <span class="n">forever</span> <span class="o">=</span> <span class="n">forever</span></code></pre>
</figure>

<p>When you call this function, it blocks infinitely, as expected. But in contrast
to Clojure and Scala’s infinite loops, this one uses no CPU! Why?</p>

<p>It turns out Haskell is <em>extremely lazy</em>. Since our function doesn’t really do anything,
it’s never really executed. You could simply print something to the screen within the
function to set Haskell on fire, but it won’t budge until you do so.</p>

<p>The <a href="http://benchmarksgame.alioth.debian.org/">Computer Language Benchmark Game</a> fell into Haskell’s lazy trap once, when
the array sorting benchmark in Haskell outperformed hand-optimized C. It turned out that
the sorted array was never printed out. So the Haskell function took the lazy way out
and did absolutely nothing, while C worked hard to sort a bunch of numbers that would
never see the light of day.</p>


    </div>
</div>

                </div>
            </div>
        </div>
    </body>
</html>
